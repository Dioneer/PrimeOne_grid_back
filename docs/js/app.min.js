/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/modules/functions.js":
/*!*************************************!*\
  !*** ./src/js/modules/functions.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "burgerMenu": () => (/* binding */ burgerMenu),
/* harmony export */   "ibg": () => (/* binding */ ibg),
/* harmony export */   "initEffect": () => (/* binding */ initEffect),
/* harmony export */   "isMobile": () => (/* binding */ isMobile),
/* harmony export */   "isWebp": () => (/* binding */ isWebp),
/* harmony export */   "map": () => (/* binding */ map),
/* harmony export */   "prallaxImage": () => (/* binding */ prallaxImage),
/* harmony export */   "responsiveMenu": () => (/* binding */ responsiveMenu)
/* harmony export */ });
const isMobile = {
	Android: function () { return navigator.userAgent.match(/Android/i); },
	BlackBerry: function () { return navigator.userAgent.match(/BlackBerry/i); },
	iOS: function () { return navigator.userAgent.match(/iPhone|iPad|iPod/i); },
	Opera: function () { return navigator.userAgent.match(/Opera Mini/i); },
	Windows: function () { return navigator.userAgent.match(/IEMobile/i); },
	any: function () { return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()); }
};

function isWebp() {
	// Проверка поддержки webp
	function testWebP(callback) {
		let webP = new Image();
		webP.src = "https://www.gstatic.com/webp/gallery/1.webp";

		webP.onload = function () {
			callback(webP.height > 0);
		};
		webP.onerror = function () {
			callback(false);
		};
	}
	// Добавление класса _webp или _no-webp для HTML
	testWebP((support) => {
		let className = support === true ? 'webp' : 'no-webp';
		document.documentElement.classList.add(className);
	});
}
function responsiveMenu() {
	const mediaQuerry = window.matchMedia("(max-width: 767.98px)");
	const leftMenu = document.querySelector('.down-line__list_left');
	const rightMenu = document.querySelector('.down-line__list_right');
	const langs = document.querySelector('.up-line__lang');
	const langsContainer = document.querySelector('.up-line');
	const logo = document.querySelector('.logo-down-line');
	const headerBurger = document.querySelector('.header__burger');
	const menu = document.querySelector('.header__menu');
	const menuHome = document.querySelectorAll('.down-line__column');
	if (mediaQuerry.matches) {
		menu.append(leftMenu, rightMenu, langs);
		headerBurger.after(logo);
		initEffect();
	} else {
		menuHome[0].append(leftMenu);
		menuHome[1].append(logo);
		menuHome[2].append(rightMenu);
		langsContainer.prepend(langs);
	}
	mediaQuerry.addEventListener('change', () => {
		if (mediaQuerry.matches) {
			menu.append(leftMenu, rightMenu, langs);
			headerBurger.after(logo);
		} else {
			menuHome[0].append(leftMenu);
			menuHome[1].append(logo);
			menuHome[2].append(rightMenu);
			langsContainer.prepend(langs);
		}
	})
}

function burgerMenu() {
	let burgerButton = document.querySelector('.header__burger');
	let burgerMenu = document.querySelector('.header__menu');
	const langs = document.querySelectorAll('.up-line__link');
	if (burgerButton) {
		burgerButton.addEventListener('click', () => {
			burgerButton.classList.toggle('active')
			burgerMenu.classList.toggle('active');
			document.body.classList.toggle('lock');
			document.querySelector('header').classList.toggle('active');
		});
	}
	langs.forEach(lang => {
		lang.addEventListener('click', (e) => {
			e.preventDefault();
			langs.forEach(langRemove => langRemove.classList.remove('active'));
			lang.classList.add('active');
		});
	})
}


function initEffect() {
	const listWrapper = document.querySelectorAll('[data-lineEffect]');
	// проверяем наличие ссылок и стартуем
	listWrapper.forEach(list => {
		const links = list.querySelectorAll('a');
		const effectSpeed = list.dataset.lineEffect ? list.dataset.lineEffect : 0.4;
		links.length ? startEffect(links, effectSpeed) : null;
	});
}
// создаем внутренние спаны с дубликатами текста и позицианируем над основными
function startEffect(links, effectSpeed) {
	const effectTransition = `transition: transform ${effectSpeed}s ease;`;
	const effectHover = `transform: translate3d(0px, 0%, 0px);`;
	const effectTop = `transform: translate3d(0px, -100%, 0px);`;
	const effectBottom = `transform: translate3d(0px, 100%, 0px);`;
	links.forEach(link => {
		link.insertAdjacentHTML('beforeend', `<span class="hover">
		<span class="hover__text">${link.textContent}</span>
		</span>`);
		if (isMobile.any()) {
			link.addEventListener('touchstart', menulinkActions);
			link.addEventListener('touchend', menulinkActions);
			document.documentElement.classList.add('touch')
		} else {
			document.documentElement.classList.remove('touch')
		}
	});

	// создаем сам эффект
	function menulinkActions(e) {
		const targetLink = e.target;
		const targetFirstSpan = targetLink.querySelector('.hover');
		const targetSecondSpan = targetLink.querySelector('.hover__text');
		const targetLinkHeight = targetLink.offsetHeight / 2;
		const targetLinkPos = e.changedTouches[0].pageY - (targetLink.getBoundingClientRect().top + scrollY);
		if (e.type === 'touchstart') {
			// присваиваем спанам значения трансформа
			targetFirstSpan.style.cssText = targetLinkPos > targetLinkHeight ? effectBottom : effectTop;
			targetSecondSpan.style.cssText = targetLinkPos > targetLinkHeight ? effectTop : effectBottom;
			// // меняем спанам значения трансформа
			setTimeout(() => {
				targetFirstSpan.style.cssText = effectHover + effectTransition;
				targetSecondSpan.style.cssText = effectHover + effectTransition;
			}, 5);
		}
		if (e.type === 'touchend') {
			targetFirstSpan.style.cssText = targetLinkPos > targetLinkHeight ? effectBottom + effectTransition : effectTop + effectTransition;
			targetSecondSpan.style.cssText = targetLinkPos > targetLinkHeight ? effectTop + effectTransition : effectBottom + effectTransition;
		}
	}
}

function ibg() {
	let imgbackround = document.querySelectorAll(".ibg");
	if (imgbackround.length > 0) {
		imgbackround.forEach(imgbg => imgbg.style.backgroundImage = 'url(' + imgbg.querySelector('img').getAttribute('src') + ')');
	}
}

function prallaxImage() {
	const parallaxes = document.querySelectorAll('.parallax > img');
	parallaxes.forEach(parallax => {
		parallax.addEventListener('mousemove', (e) => {
			const parallaxWidth = parallax.offsetWidth;
			const parallaxHeight = parallax.offsetHeight;
			const coordX = e.pageX - (parallax.getBoundingClientRect().left + scrollX + parallaxWidth / 2);
			const coordY = e.pageY - (parallax.getBoundingClientRect().top + scrollY + parallaxHeight / 2);
			const perOfParallaxMoveX = coordX / parallaxWidth * 100;
			const perOfParallaxMoveY = coordY / parallaxHeight * 100;
			mouseParallax(perOfParallaxMoveX, perOfParallaxMoveY, parallax);
		})
	})
	function mouseParallax(perOfParallaxMoveX, perOfParallaxMoveY, parallax) {
		let positionX = 0;
		let positionY = 0;
		// получаем разницу между текущей и предыдущей позицией
		const distX = perOfParallaxMoveX - positionX;
		const distY = perOfParallaxMoveY - positionY;
		// текущая позиция = предыдущая позиция + разница между текущей и предыдущей позицией  * на коэфф
		positionX = positionX + (distX * 0.05);
		positionY = positionY + (distY * 0.05);
		console.log(positionX, positionY)
		// Присваиваем значения в транслейт. 50- просто коэффиициент
		parallax.style.transform = `translate(${positionX / 60 * 100}%, ${positionY / 60 * 100}%)`;
	}
}

function map() {
	let map = new ymaps.Map("map", {
		center: [42.352212, -71.071983],
		zoom: 15,
		autoFitToViewport: 'always',
	});
	map.controls.remove('trafficControl');
	map.controls.remove('geolocationControl');
	map.controls.remove('rulerControl');
	map.controls.remove('zoomControl');
	map.controls.remove('typeSelector');
	map.controls.remove('searchControl');
	if (map) {
		let myPlacemark = new ymaps.Placemark([42.352212, -71.071983], {
			balloonContentHeader: "Prime One",
			balloonContentBody: "Nyam-Nyam"
		}, {
			iconLayout: 'default#image',
			iconImageHref: "~/../img/icons/02.jpg",
			iconImageSize: [40, 50],
			iconImageOffset: [-20, -20]
		});
		map.geoObjects.add(myPlacemark);

	}
}

/***/ }),

/***/ "./src/js/modules/validationForms.js":
/*!*******************************************!*\
  !*** ./src/js/modules/validationForms.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "validationForm": () => (/* binding */ validationForm)
/* harmony export */ });


// data-value="" - для обнудления полей and placeholder
// data-error="ошибка" - для текста ошибки в доп. элементе
// req - класс для валидируемых полей
// form__error - класс созадется для блока с ошибочным текстом
// email - класс для валидации почты
// goto-error - класс переход к ошибке, вешается на форму

// начало работы до загрузки картинок
function validationForm() {
	let forms = document.querySelectorAll('form');
	if (forms.length > 0) {
		forms.forEach(form => {
			form.addEventListener('submit', form_submit);
		})
	}
}
async function form_submit(e) {
	e.preventDefault();
	let btn = e.target;
	let form = btn.closest('form');
	// подсчет ошибок
	let error = getErrors(form);
	if (error === 0) {
		let formData = new FormData(form);
		// очищаем форму
		form_clean(form);
		// вешаем окно при долгой отправке
		const formAction = form.getAttribute('action') ? form.getAttribute('action').trim() : '#';
		const formMethod = form.getAttribute('method') ? form.getAttribute('method').trim() : 'GET';
		form.classList.add('sending');
		let response = await fetch(formAction, {
			method: formMethod,
			// mode: 'no-cors',
			body: formData
		});
		if (response.ok) {
			let result = await response.json();
			console.log(result)
			form.classList.remove('sending');
			document.addEventListener('formSent', () => popup(`Форма отправлена!`))
			formSent(result);
		}
		else {
			popup('response not ok');
			form.classList.remove('sending');
		}
	} else {
		// вызываем попап или скролл к блоку
		popup('Necessary fildes is not fiil')
		let form_error = form.querySelectorAll('.error');
		if (form_error && form.classList.contains('goto-error')) {
			smoothScroll(form_error[0])
		}
	}
}

// Действия после отправки формы
function formSent(result) {
	if (result && window.Event) {
		// Создаем событие отправки формы
		let event = new CustomEvent("formSent", {
			detail: {
				message: 'ok',
			},
			bubbles: true,
			cancelable: true
		});
		document.dispatchEvent(event)
	}
}

// проверка на скрытие input
function getErrors(form) {
	let error = 0
	let formRequiredItems = form.querySelectorAll('.req');
	if (formRequiredItems.length) {
		formRequiredItems.forEach(formRequiredItem => {
			if ((formRequiredItem.offsetParent !== null || formRequiredItem.tagName === "SELECT") && !formRequiredItem.disabled) {
				error += formValidate(form);
			}
		});
	}
	return error;
}

// функция валидации
function formValidate(form) {
	let error = 0;
	let formRequiredItems = form.querySelectorAll('.req');
	formRequiredItems.forEach(req => {
		formRemoveError(req);
		if (!req.value || req.value === ' ' || req.value === req.getAttribute("data-value")) {
			formAddError(req);
			error++;
		}
	})
	return error;
}
// накидываем ошибки
function formAddError(req) {
	req.parentElement.classList.add('error');
	req.classList.add('error');

	// убираем существующий блок с ошибкой, если есть, что бы не плодились=) и создаем блок с ошибкой и текстом
	let input_error = req.parentElement.querySelector('.form__error');
	if (input_error) {
		input_error.remove();
	}
	let input_error_text = req.getAttribute('data-error');
	if (input_error_text && input_error_text != '') {
		req.parentElement.insertAdjacentHTML('beforeend', '<div class="form__error">' + input_error_text + '</div>');
	}
}

function formRemoveError(req) {
	req.parentElement.classList.remove('error');
	req.classList.remove('error');

	// убираем блок с ошибкой и текстом
	let input_error = req.parentElement.querySelector('.form__error');
	if (input_error) {
		input_error.remove();
	}
}

function form_clean(form) {
	form.reset();
	setTimeout(() => {
		let inputs = form.querySelectorAll('input[type="text"],input[type="password"],textarea');
		inputs.forEach(inpTextArr => {
			// Это для textarrea
			inpTextArr.parentElement.classList.remove('focus');
			inpTextArr.classList.remove('focus');
			inpTextArr.value = inpTextArr.getAttribute('data-value');
		})
	}, 0);
}

// вешаем классы и снимаем по клику на крестик
function popup(text) {
	const popup = document.querySelector('.popup');
	const textinp = document.querySelector('.popup__text');
	document.documentElement.classList.add('popup-show');
	popup.classList.add('popup_show');
	textinp.textContent = text;
	document.querySelector('.popup__close').addEventListener('click', (e) => {
		e.preventDefault();
		document.documentElement.classList.remove('popup-show');
		popup.classList.remove('popup_show');
	})
}

// стандартно получаем координаты блока с ошибкой
function getCoords(elem) {
	let box = elem.getBoundingClientRect();
	return {
		top: box.top + window.pageYOffset,
		right: box.right + window.pageXOffset,
		bottom: box.bottom + window.pageYOffset,
		left: box.left + window.pageXOffset
	};
}

function smoothScroll(firstErr) {
	const startY = window.pageYOffset;
	const stopY = getCoords(firstErr).top;
	// дистанция на которую надопрокрутить
	let distance = stopY > startY ? stopY - startY : startY - stopY;
	if (distance < 100) {
		window.scrollTo(0, stopY);
		return;
	}
	let speed = Math.round(distance / 100);
	if (speed >= 20) { speed = 20 } else { speed = 30 }
	const step = Math.round(distance / 25);
	// если место кнопки submit больше, чем место ошибки, вычитаем шаги
	let leapY = stopY > startY ? startY + step : startY - step;
	let timer = 0;
	// если ошибка больше кнопки
	if (stopY > startY) {
		for (let i = startY; i < stopY; i += step) {
			setTimeout(`window.scrollTo(0,${leapY})`, timer * speed);
			leapY += step; if (leapY > stopY) leapY = stopY; timer++;
		}
	}
	// если кнопка больше ошибки
	for (let i = startY; i > stopY; i -= step) {
		setTimeout(window.scrollTo.bind(null, 0, leapY), timer * speed);
		leapY -= step;
		if (leapY < stopY) leapY = stopY;
		timer++;
	}

}

//Placeholers
// при фокусе навешивает focus на input и parentelement
let inputs = document.querySelectorAll('input[data-value],textarea[data-value]');
inputs_init(inputs);
function inputs_init(inputs) {
	if (inputs.length > 0) {
		inputs.forEach(input => {
			const dataValue = input.getAttribute('data-value');
			// записываем значение аттриботу в плейсхолдер
			input_placeholder_add(input);
			// при фокусе накидываем классы фокуса и обнуляем значение
			input.addEventListener('focus', function (e) {
				if (input.value == dataValue) {
					input_focus_add(input);
					input.value = '';
				}
				formRemoveError(input);
			});
			// при потере фокуса убираем классы фокуса и добавляем значение
			input.addEventListener('blur', function (e) {
				if (input.value == '') {
					input.value = dataValue;
					input_focus_remove(input);
					if (input.getAttribute('data-type') === "pass") {
						input.setAttribute('type', 'text');
					}
				}
			});

		})
	}
}
function input_placeholder_add(input) {
	const dataValue = input.getAttribute('data-value');
	if (dataValue != '') {
		input.value = dataValue;
	}
}
function input_focus_add(input) {
	input.classList.add('focus');
	input.parentElement.classList.add('focus');
}
function input_focus_remove(input) {
	input.classList.remove('focus');
	input.parentElement.classList.remove('focus');
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/functions.js */ "./src/js/modules/functions.js");
/* harmony import */ var _modules_validationForms_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/validationForms.js */ "./src/js/modules/validationForms.js");


;


document.addEventListener('DOMContentLoaded', (e) => {

	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.isWebp();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.responsiveMenu();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.burgerMenu();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.ibg();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.prallaxImage();
	(0,_modules_validationForms_js__WEBPACK_IMPORTED_MODULE_1__.validationForm)();
	ymaps.ready(_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.map);
})

})();

/******/ })()
;
//# sourceMappingURL=app.min.js.map